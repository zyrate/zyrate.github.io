<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 5.4.2">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.19.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://gcore.jsdelivr.net'>
  <link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>MIT6.824 分布式系统课程实验笔记 Lab 1 - zyrate's Blog</title>

  
    <meta name="description" content="MIT 6.824 是麻省理工大学的一门研究生课程——Distributed Systems，学习这门课程对于了解分布式系统的构建原理、理解分布式程序的运行、优化分布式程序的运行环境会有很大的帮助。课程内容涵盖：分布式、容错、多副本、一致性等议题，附带了 4 个大的实验 Lab 并配套了相关的测试用例，需要基于 Go 语言完成。Lab 会将课程所讲的知识进行实践、贯通，有助于加深我们的理解和记忆。">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT6.824 分布式系统课程实验笔记 Lab 1">
<meta property="og:url" content="https://zyrate.github.io/2023/12/01/824%20Lab%201/index.html">
<meta property="og:site_name" content="zyrate&#39;s Blog">
<meta property="og:description" content="MIT 6.824 是麻省理工大学的一门研究生课程——Distributed Systems，学习这门课程对于了解分布式系统的构建原理、理解分布式程序的运行、优化分布式程序的运行环境会有很大的帮助。课程内容涵盖：分布式、容错、多副本、一致性等议题，附带了 4 个大的实验 Lab 并配套了相关的测试用例，需要基于 Go 语言完成。Lab 会将课程所讲的知识进行实践、贯通，有助于加深我们的理解和记忆。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://picgo-1259339555.cos.ap-nanjing.myqcloud.com/20231128102949.png">
<meta property="og:image" content="https://picgo-1259339555.cos.ap-nanjing.myqcloud.com/20231130211155.png">
<meta property="og:image" content="https://picgo-1259339555.cos.ap-nanjing.myqcloud.com/20231130200613.png">
<meta property="article:published_time" content="2023-11-30T16:00:00.000Z">
<meta property="article:modified_time" content="2024-03-12T10:00:01.114Z">
<meta property="article:author" content="Yunrui Zheng">
<meta property="article:tag" content="go">
<meta property="article:tag" content="mit6824">
<meta property="article:tag" content="分布式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://picgo-1259339555.cos.ap-nanjing.myqcloud.com/20231128102949.png">
  
  
  
  <meta name="keywords" content="go,mit6824,分布式">

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="zyrate's Blog" type="application/atom+xml">
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  
    <link rel="shortcut icon" href="https://picgo-1259339555.cos.ap-nanjing.myqcloud.com/%E7%82%B9%E7%81%AB%E6%9F%B4.svg">
  

  

  


  
    
      <link href="https://gcore.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/lxgwwenkaiscreen.css" rel="stylesheet">
    
  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    

  

<header class="header"><div class="logo-wrap"><a class="title" href="/"><div class="main" ff="title">zyrate's Blog</div><div class="sub cap">为者常成，行者常至</div></a></div>

<nav class="menu dis-select"></nav>
</header>


<div class="widgets">
<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search"><form class="search-form"><input type="text" class="search-input" id="search-input" data-filter="/blog/" placeholder="文章搜索"><svg t="1670596976048" class="icon search-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2676" width="200" height="200"><path d="M938.2 832.6L723.8 618.1c-2.5-2.5-5.3-4.4-7.9-6.4 36.2-55.6 57.3-121.8 57.3-193.1C773.3 222.8 614.6 64 418.7 64S64 222.8 64 418.6c0 195.9 158.8 354.6 354.6 354.6 71.3 0 137.5-21.2 193.2-57.4 2 2.7 3.9 5.4 6.3 7.8L832.5 938c14.6 14.6 33.7 21.9 52.8 21.9 19.1 0 38.2-7.3 52.8-21.8 29.2-29.1 29.2-76.4 0.1-105.5M418.7 661.3C284.9 661.3 176 552.4 176 418.6 176 284.9 284.9 176 418.7 176c133.8 0 242.6 108.9 242.6 242.7 0 133.7-108.9 242.6-242.6 242.6" p-id="2677"></path></svg></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div></div></widget>


<widget class="widget-wrapper toc single" id="data-toc"><div class="widget-header cap dis-select"><span class="name">MIT6.824 分布式系统课程实验笔记 Lab 1</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%9A%E5%89%8D%E5%87%86%E5%A4%87"><span class="toc-text">做前准备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MapReduce-%E5%8E%9F%E7%90%86"><span class="toc-text">MapReduce 原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">需要考虑的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Master-%E5%92%8C-Worker-%E6%98%AF%E4%BD%95%E6%97%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%EF%BC%9F%E5%9C%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E5%90%84%E8%87%AA%E6%8E%A5%E6%94%B6%E4%BA%86%E5%93%AA%E4%BA%9B%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="toc-text">1 . Master 和 Worker 是何时初始化的？在初始化时各自接收了哪些参数？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Master-%E5%92%8C-Worker-%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1%EF%BC%8C%E6%98%AF%E5%90%8E%E8%80%85%E4%B8%BB%E5%8A%A8%E8%81%94%E7%B3%BB%E5%89%8D%E8%80%85%E8%BF%98%E6%98%AF%E7%9B%B8%E5%8F%8D%EF%BC%9F"><span class="toc-text">2. Master 和 Worker 之间如何通信，是后者主动联系前者还是相反？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-Master-%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%E4%B8%8D%E5%90%8C%E7%9A%84-Worker%EF%BC%9F"><span class="toc-text">3. Master 如何区分不同的 Worker？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-Map-%E5%92%8C-Reduce-%E4%BB%BB%E5%8A%A1%E5%88%86%E5%88%AB%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA%EF%BC%9F"><span class="toc-text">4. Map 和 Reduce 任务分别有多少个？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-Master-%E5%A6%82%E4%BD%95%E5%9C%A8%E7%9B%B8%E5%BA%94%E7%9A%84%E9%98%B6%E6%AE%B5%E5%88%86%E9%85%8D-Map-%E5%92%8C-Reduce-%E4%BB%BB%E5%8A%A1%EF%BC%9F%E9%9C%80%E8%A6%81%E4%BC%A0%E9%80%92%E4%BB%80%E4%B9%88%E5%8F%82%E6%95%B0%E7%BB%99-Worker%EF%BC%9FWorker-%E5%9C%A8%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%E4%BB%A5%E5%90%8E%E9%9C%80%E8%A6%81%E8%BF%94%E5%9B%9E%E4%BB%80%E4%B9%88%E7%BB%93%E6%9E%9C%E7%BB%99-Master%EF%BC%9F"><span class="toc-text">5. Master 如何在相应的阶段分配 Map 和 Reduce 任务？需要传递什么参数给 Worker？Worker 在完成一个任务以后需要返回什么结果给 Master？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E5%A6%82%E6%9E%9C%E6%9F%90%E4%B8%80%E4%B8%AA-Worker-%E6%8E%89%E7%BA%BF%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">6. 如果某一个 Worker 掉线了怎么办？</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MapReduce-%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-text">MapReduce 具体实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Worker-%E5%AE%9E%E7%8E%B0"><span class="toc-text">Worker 实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Master-%E5%AE%9E%E7%8E%B0"><span class="toc-text">Master 实现</span></a></li></ol></li></ol></div></div></widget>




</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" href="https://github.com/zyrate" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/social/08a41b181ce68.svg"/></a></div></footer>

    </aside>
    <div class='l_main'>
      

      



<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" href="/">文章</a></div><div id="post-meta">发布于&nbsp;<time datetime="2023-11-30T16:00:00.000Z">2023-12-01</time></div></div>

<article class='md-text content post'>
<h1 class="article-title"><span>MIT6.824 分布式系统课程实验笔记 Lab 1</span></h1>
<p>MIT 6.824 是麻省理工大学的一门研究生课程——Distributed Systems，学习这门课程对于了解分布式系统的构建原理、理解分布式程序的运行、优化分布式程序的运行环境会有很大的帮助。课程内容涵盖：分布式、容错、多副本、一致性等议题，附带了 4 个大的实验 Lab 并配套了相关的测试用例，需要基于 Go 语言完成。Lab 会将课程所讲的知识进行实践、贯通，有助于加深我们的理解和记忆。</p>
<h2 id="做前准备"><a href="#做前准备" class="headerlink" title="做前准备"></a>做前准备</h2><p>网上对于本课程 Lab 的实现很多，但是大部分都是上来就讲原理和代码，很少有提到如何从头开始，而第一步往往是最难的。下面是一些准备工作和注意事项：</p>
<ol>
<li>首先，这门课程的 Lab 是完全用 Go 写的，Lecture 也会时不时的讲到 Go 代码，所以需要提前熟悉 Go 的一些基础知识。语言只是一个工具，不必望而却步，只要之前能熟练使用 Java、C++等任何一门编程语言的都可以很快上手 Go，对于完成这门课程足够用了。</li>
<li>MIT 6.824 课程之所以很出名，原因之一就是其主讲人是 Robert Morris 教授，这是一个传奇大佬，课讲得很好。但似乎 2020 年以后他就不讲这门课了，所以我听的就是他的 2020 年课程，B 站资源：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1R7411t71W/?spm_id_from=333.337.search-card.all.click&vd_source=1c742f240c2781a55574a4a7db3144c0">2020 MIT 6.824 分布式系统_哔哩哔哩_bilibili</a>，目前网上免费资源大部分都是机翻字幕，有一些人工翻译的但并不完全。有个网站 <a target="_blank" rel="noopener" href="https://www.simtoco.com/">https://www.simtoco.com/</a> 可以付费购买全部翻译课程，质量挺不错的。</li>
<li>关于 Lab 资源，我做的是 2022 年的版本，因为 2020 年项目的 Go 版本有些落后，不过其实都无所谓，每一年的 Lab 内容基本上是一样的。网址：<a target="_blank" rel="noopener" href="http://nil.csail.mit.edu/6.824/2022/">6.824 Home Page: Spring 2022 (mit.edu)</a></li>
<li>可以先把项目 clone 下来（在 Lab 1 页面的开头有介绍），这门课程要求学习者不得把自己的仓库公开，以免出现作弊情况，所以如果要 push 到 GitHub 上的话记得把仓库设为私有。</li>
<li>接下来就可以开始先看 Lecture 了，总共有 20 个 Lec，每个 Lec 前一般都会分配一篇论文阅读（在 Schedule 页面），尽量先读过一遍。其实看完第一课就可以做 Lab 1 了，实现一个简易的分布式 MapReduce 只需要使用 RPC 和一定的容错（虽然并不容易），用不到多副本、一致性等内容。Lab 1 更像是一次牛刀小试，Lab 2~4 才会用到课程所授的大部分知识。</li>
</ol>
<p>每个 Lab 提供了一些框架性的代码，需要自己编写关键代码，然后通过测试。具体需要在哪里动笔，课程网页都提供了详细的说明。比如 Lab 1，他已经写好了一个串行的 MapReduce 逻辑，提供了用于 word count 的 Map 和 Reduce 函数。我们先按照指南进行测试，看是否能输出正确结果，如果可以的话就开始着手写分布式 MapReduce 了（在 <code>mr/</code> 目录下的三个文件中）。</p>
<h2 id="MapReduce-原理"><a href="#MapReduce-原理" class="headerlink" title="MapReduce 原理"></a>MapReduce 原理</h2><p>通过阅读论文，我们可以知道 MapReduce 的作者是如何设计这个模型的：</p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://picgo-1259339555.cos.ap-nanjing.myqcloud.com/20231128102949.png" alt="MapReduce原理模型"/></div><div class="image-meta"><span class="image-caption center">MapReduce原理模型</span></div></div>

<p>MapReduce 执行过程</p>
<ol>
<li>用户程序中的 MapReduce 库（Client 端）首先将输入文件分割为 M 块，然后在集群上启动许多该程序的副本；</li>
<li>其中一个副本是 master，其余的是 worker。总共有 M 个 map 任务和 R 个 reduce 任务需要 master 挑选一个空闲的 worker 进行分配；</li>
<li> 分配了 map 任务的 worker 读取相应输入 split 的内容。它从输入数据中解析键/值对，并将每对传递给用户定义的 map 函数。 map 函数生成的中间键/值对缓冲在内存中；</li>
<li>定期将键值对写入本地磁盘，并通过分区函数将其分为 R 个区域。这些键值在本地磁盘上的位置被传回 master，主节点负责将这些位置转发给 reduce 工作节点；</li>
<li>当一个 reduce worker 被通知位置后，通过 RPC 去读取 map workers 上的键值对，（并排序）；</li>
<li>reduce worker 遍历所有的已排序键值对，将唯一的键和值集合传递给用户的 reduce 函数，函数输出到最终文件（最多 R 个）；</li>
<li>当所有的 reduce 完成任务后，master 唤醒（通知）用户程序。</li>
</ol>
<p>整体流程还是比较清晰的，但是上述内容仅仅是一个逻辑模型，具体如何进行实现还是需要考虑很多问题的，并且与逻辑模型可能会有一些出入。</p>
<h2 id="需要考虑的问题"><a href="#需要考虑的问题" class="headerlink" title="需要考虑的问题"></a>需要考虑的问题</h2><p>要真正实现 MapReduce，搞清以下几个问题很重要：</p>
<h5 id="1-Master-和-Worker-是何时初始化的？在初始化时各自接收了哪些参数？"><a href="#1-Master-和-Worker-是何时初始化的？在初始化时各自接收了哪些参数？" class="headerlink" title="1 . Master 和 Worker 是何时初始化的？在初始化时各自接收了哪些参数？"></a>1 . Master 和 Worker 是何时初始化的？在初始化时各自接收了哪些参数？</h5><p>假设集群中每个机器运行一个 Master 或 Worker，这个概念并不是属于某个机器的，它只是这个机器上运行的一个进程。Master 和 Worker 是在用户向集群提交某次计算任务后才初始化的，用户提交的任务内容包括：<strong>输入文件路径</strong>、<strong>Map 函数</strong>、<strong>Reduce 函数</strong>。初始化的动作是由论文中提到的 “user program 调用的 MapReduce 库” 也就是整体框架进行的。</p>
<p>一般来说，MapReduce 系统的运行需要一个分布式文件系统的支持（如 HDFS），输入、输出文件均通过该系统的统一接口。</p>
<ul>
<li>Master 初始化时接收的参数是：输入文件路径、分区数 R</li>
<li>Worker 初始化时接收的参数是：Map 函数，Reduce 函数</li>
</ul>
<h5 id="2-Master-和-Worker-之间如何通信，是后者主动联系前者还是相反？"><a href="#2-Master-和-Worker-之间如何通信，是后者主动联系前者还是相反？" class="headerlink" title="2. Master 和 Worker 之间如何通信，是后者主动联系前者还是相反？"></a>2. Master 和 Worker 之间如何通信，是后者主动联系前者还是相反？</h5><p>大概有两种方式：</p>
<ul>
<li>一种是 Worker 启动时向 Master 进行注册， Master 定时向 Worker 发送心跳确认其在线，并在有任务需要分配时主动通知 Worker。这也是论文的做法。</li>
<li>另一种是 Worker 不间断地向 Master 发送心跳，Master 接收到心跳时，将任务信息以回应的方式返回给 Worker。</li>
</ul>
<p>我采用的是第二种做法，也是 Lab 倾向的做法。因为这样不论是 Master 和 Worker 实现起来要简洁一些，Worker 端不需要启动 RPC 服务器，性能也不输第一种。也是由于本 Lab 是运行在单机上的（为了测试方便），且采用了<strong>UNIX 域套接字</strong>进行进程间通信，所以在横向扩展 Worker 时第二种方式更加方便。</p>
<blockquote>
<p>UNIX 域套接字用于在同一台计算机上运行的进程之间的通信。虽然因特网域套接字可用于同一目的，但 UNIX 域套接字的效率更高。UNIX 域套接字仅仅复制数据，它们并不执行协议处理，不需要添加或删除网络报头，无需计算校验和，不要产生顺序号，无需发送确认报文。</p>
</blockquote>
<h5 id="3-Master-如何区分不同的-Worker？"><a href="#3-Master-如何区分不同的-Worker？" class="headerlink" title="3. Master 如何区分不同的 Worker？"></a>3. Master 如何区分不同的 Worker？</h5><p>Master 区分不同的 Worker 是为了记录任务的<strong>分配和执行</strong>情况，以便在出现异常时及时处理。</p>
<p>因为本次 Lab 是在一台机器上运行，所以不考虑 Worker 的网络地址。Master 可以<strong>通过 ID</strong> 来区分 Worker。在首次请求 Task 的时候让 Master 去赋予 Worker 一个全局唯一的 ID，这个 ID 的有效期直到 Job 运行结束。</p>
<h5 id="4-Map-和-Reduce-任务分别有多少个？"><a href="#4-Map-和-Reduce-任务分别有多少个？" class="headerlink" title="4. Map 和 Reduce 任务分别有多少个？"></a>4. Map 和 Reduce 任务分别有多少个？</h5><p>Map 任务的个数取决于输入文件的 split 个数，这个 split 的过程在论文中是由<strong>库函数</strong>进行的，但是一般来说在一个分布式文件系统中，它存储文件的方式本身就是 split 的形式，因此这一步视情况可以省略。在本 Lab 中，<code>pg-</code> 开头的每一个输入文件就是一个 split，它们的文件名被传给 Master 端。</p>
<p>Reduce 任务的个数<strong>小于等于</strong>分区数 R，是由用户指定的。Map 函数读取 split 文件生成大量的 KV 对，然后根据 <code>hash(key) % R</code> 的结果将中间键空间划分为 R 个片段，将每个片段的 KV 对输出到一个中间文件中去，每个中间文件都将被输入到一个 Reduce 函数。但是如果 KV 对的数量较少或者是数据较为倾斜，那么最终并不一定有 R 个文件，也就不一定有 R 个 Reduce 任务，所以 Reduce 任务的数量是不一定的，最大为 R。</p>
<p>但是在 Lab 代码中，官方将传递给 Master 的分区数 R 的变量命名为 <code>nReduce</code>，这其实是一种误导，所以我将它改成了 <code>partition</code>。</p>
<h5 id="5-Master-如何在相应的阶段分配-Map-和-Reduce-任务？需要传递什么参数给-Worker？Worker-在完成一个任务以后需要返回什么结果给-Master？"><a href="#5-Master-如何在相应的阶段分配-Map-和-Reduce-任务？需要传递什么参数给-Worker？Worker-在完成一个任务以后需要返回什么结果给-Master？" class="headerlink" title="5. Master 如何在相应的阶段分配 Map 和 Reduce 任务？需要传递什么参数给 Worker？Worker 在完成一个任务以后需要返回什么结果给 Master？"></a>5. Master 如何在相应的阶段分配 Map 和 Reduce 任务？需要传递什么参数给 Worker？Worker 在完成一个任务以后需要返回什么结果给 Master？</h5><p>关于这几个问题，概述如下：<br>    1. worker 循环调用 master 的 rpc 方法去获取任务（心跳），直到收到“结束”指令。<br>    2. worker 收到 map 任务，从一个 split 文件读取数据并执行 map 函数，将缓冲对写入本地磁盘。<br>    3. 当所有的 M 个 map 任务执行完毕后，master 开始分配 reduce 任务，仍然是 worker 主动获取。<br>    4. worker 收到 reduce 任务，读取对应 worker 磁盘上的中间数据（这里就是本地的数据，因为在一台机器上运行），执行 reduce ()函数，将结果输出到一个最终 output 文件。</p>
<p>画了一张图：</p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://picgo-1259339555.cos.ap-nanjing.myqcloud.com/20231130211155.png" alt="MapReduce数据流向示意图"/></div><div class="image-meta"><span class="image-caption center">MapReduce数据流向示意图</span></div></div>

<p>其中，箭头是数据/信息流动的方向，蓝色代表 Map 阶段，红色代表 Reduce 阶段。整体的运行流程按照<strong>序号顺序</strong>进行。注意，同一个 Worker 可能先后完成多个 Map 和 Reduce 任务，图中的 Worker 编号只是一个示意。Master 相当于服务端，Worker 不断发送请求。在本 Lab 中，DFS 就是本地文件系统。</p>
<h5 id="6-如果某一个-Worker-掉线了怎么办？"><a href="#6-如果某一个-Worker-掉线了怎么办？" class="headerlink" title="6. 如果某一个 Worker 掉线了怎么办？"></a>6. 如果某一个 Worker 掉线了怎么办？</h5><p>Master 端需要进行简单的容错，我采取的方式是：在 Master 分配给 Worker 一个任务后，异步计时等待（如 10 秒），等待结束后如果该 Worker 还没有返回计算结果，那么就认为该 Worker 掉线了，需要重新分配此任务。</p>
<h2 id="MapReduce-具体实现"><a href="#MapReduce-具体实现" class="headerlink" title="MapReduce 具体实现"></a>MapReduce 具体实现</h2><p>代码细节较多，只记录较重要的部分。</p>
<h3 id="Worker-实现"><a href="#Worker-实现" class="headerlink" title="Worker 实现"></a>Worker 实现</h3><p>每个 Worker 只管接受任务、执行计算、返回结果，不需要管别的，所以可以先从 Worker 写起。</p>
<p>每当 Worker 通过 RPC 向 Master 发送心跳请求的时候，会收到 4 种可能的回应：</p>
<ul>
<li><code>HEATBEAT</code>：Master 的回应心跳，代表现在 Master 没有任务可分配，Worker 暂时空闲；</li>
<li><code>MAPTASK</code>：Master 向自己分配了一个 Map 任务，附带的信息有<strong>任务编号 X、输入文件路径、分区数 R</strong>；</li>
<li><code>REDUCETASK</code>：Master 向自己分配了一个 Reduce 任务，附带的信息有<strong>任务编号 Y、所有的中间文件路径</strong>；</li>
<li><code>QUIT</code>：计算 Job 的 Map 和 Reduce 阶段已全部完成，可以退出程序。</li>
</ul>
<p>初始化代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Worker</span><span class="params">(mapf <span class="keyword">func</span>(<span class="type">string</span>, <span class="type">string</span>)</span></span> []KeyValue, reducef <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>, []<span class="type">string</span>)</span></span> <span class="type">string</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		request := Request&#123;&#125;</span><br><span class="line">		reply := Reply&#123;&#125;</span><br><span class="line">		request.WorkerId = workerId <span class="comment">// 初始值为0</span></span><br><span class="line">		<span class="comment">// 通过RPC向Master发送心跳</span></span><br><span class="line">		ok := call(<span class="string">&quot;Coordinator.HeartbeatHandler&quot;</span>, &amp;request, &amp;reply)</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;call Coordinator.HeartbeatHandler failed!\n&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> workerId == <span class="number">0</span> &#123;</span><br><span class="line">			workerId = reply.WorkerId <span class="comment">// 首次获取到Master分配的ID</span></span><br><span class="line">			setLogFile()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">switch</span> reply.Command &#123;</span><br><span class="line">		<span class="keyword">case</span> QUIT: <span class="comment">// 结束</span></span><br><span class="line">			deleteIntermediates() <span class="comment">// 删除产生的所有中间文件</span></span><br><span class="line">			log.Println(<span class="string">&quot;Quit.&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> HEARTBEAT:</span><br><span class="line">			log.Println(<span class="string">&quot;Receive Heartbeat with master.&quot;</span>)</span><br><span class="line">		<span class="keyword">case</span> MAPTASK: <span class="comment">// 分配了map任务</span></span><br><span class="line">			log.Println(<span class="string">&quot;Got map task:&quot;</span>, reply)</span><br><span class="line">			doMapTask(reply.Task, mapf, reply.NReduce)</span><br><span class="line">		<span class="keyword">case</span> REDUCETASK: <span class="comment">// 分配了reduce任务</span></span><br><span class="line">			log.Println(<span class="string">&quot;Got reduce task:&quot;</span>, reply)</span><br><span class="line">			doReduceTask(reply.Task, reducef)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 心跳间隔</span></span><br><span class="line">		time.Sleep(time.Second * time.Duration(HEARTBEAT_INTERVAL))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Worker 在初始化后 ID 为 0，Master 在遇见 ID 为 0 的请求后，会从 1 开始累加，向 Worker 分配 ID，Worker 需要保存这个 ID 直到程序结束，在随后的每次请求都要附上自己的 ID。</p>
<p><strong>在收到 Map 任务时：</strong></p>
<ol>
<li>读取输入文件的全部内容；</li>
<li>调取用户的 map 函数，得到 KV 数组：<code>kva := mapf(filename, string(content))</code>；</li>
<li>遍历 KV 数组的每一个 KV：<ol>
<li>计算当前 KV 应属分区号 Y：<code>partition := ihash(kv.Key) % nReduce</code></li>
<li>如果不存在，新建中间文件：<code>mr-X-Y</code></li>
<li>将该 KV 以 JSON 格式输出到中间文件</li>
</ol>
</li>
<li>发送任务完成信息给 Master，内容包含所有中间文件的路径。</li>
</ol>
<p><strong>在收到 Reduce 任务时：</strong></p>
<ol>
<li>以 JSON 格式读取所有中间文件的内容到一个 KV 数组；</li>
<li>对该数组以 Key 进行排序；</li>
<li>如果不存在，新建临时结果文件：<code>mr-out-Y-随机字符</code>；</li>
<li>对于每一个 Key 和它对应的 Value 集合，调用用户的 reduce 函数：<code>output := reducef(intermediate[i].Key, values)</code></li>
<li>output 按格式输出到结果文件。</li>
<li>遍历完毕后，更改临时文件名为：<code>mr-out-Y</code>。</li>
<li>发送任务完成信息给 Master。</li>
</ol>
<blockquote>
<p>临时文件的目的是为了防止 reduce 执行到一半 worker 崩溃了，却留给用户任务已完成的假象。</p>
</blockquote>
<h3 id="Master-实现"><a href="#Master-实现" class="headerlink" title="Master 实现"></a>Master 实现</h3><p>本次采用的 Master 端的模式是<strong>完全被动</strong>的，也就是不会主动去找 Worker 分配任务，这就需要通过某些设计，使得 Worker 的心跳请求到来后，判断当前是 Map 阶段还是 Reduce 阶段还是已经完成 Job 了。</p>
<p>首先看一下 Task 和 Master 的数据结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Task <span class="keyword">struct</span> &#123;</span><br><span class="line">    TaskType <span class="type">int</span>      <span class="comment">// 任务类型，Map或Reduce</span></span><br><span class="line">    TaskNo   <span class="type">int</span>      <span class="comment">// 任务编号，用于标识和文件命名</span></span><br><span class="line">    Files    []<span class="type">string</span> <span class="comment">// 文件路径信息，map就是1个输入文件，reduce就是多个中间文件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Coordinator <span class="keyword">struct</span> &#123;</span><br><span class="line">    jobDone           <span class="type">bool</span>             <span class="comment">// Job是否完成</span></span><br><span class="line">    isReducing        <span class="type">bool</span>             <span class="comment">// 当前是否是Reduce阶段</span></span><br><span class="line">    nextWorkerId      <span class="type">int</span>              <span class="comment">// 下一个新Worker的ID</span></span><br><span class="line">    nMap              <span class="type">int</span>              <span class="comment">// map任务个数</span></span><br><span class="line">    nReduce           <span class="type">int</span>              <span class="comment">// reduce任务个数</span></span><br><span class="line">    partition         <span class="type">int</span>              <span class="comment">// 分区数</span></span><br><span class="line">    unassignedMaps    <span class="keyword">chan</span> Task        <span class="comment">// 还未分配的map任务</span></span><br><span class="line">    unassignedReduces <span class="keyword">chan</span> Task        <span class="comment">// 还未分配的reduce任务</span></span><br><span class="line">    assignedMaps      <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>     <span class="comment">// 已分配的map任务，TaskNo-&gt;是否完成</span></span><br><span class="line">    assignedReduces   <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>     <span class="comment">// 已分配的reduce任务，TaskNo-&gt;是否完成</span></span><br><span class="line">    working           <span class="keyword">map</span>[<span class="type">int</span>]*Task    <span class="comment">// 正在工作的worker记录，ID-&gt;Task</span></span><br><span class="line">    intermediates     <span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">string</span> <span class="comment">// 中间文件名集合，reduceNo-&gt;files</span></span><br><span class="line">    mu                sync.Mutex       <span class="comment">// 互斥锁，保证并发安全</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我采用的是 Go 的 <strong>Buffered Channel</strong> 进行任务分配。在 Master 初始化的时候，先将每一个输入 split 文件创建一个 MapTask，并压入未分配 Map 任务的队列：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化map任务</span></span><br><span class="line"><span class="keyword">for</span> index, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">	c.unassignedMaps &lt;- Task&#123;MAPTASK, index, []<span class="type">string</span>&#123;file&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是应对 Worker 的 RPC 请求处理函数了，总共有三个：</p>
<ul>
<li><code>HeartbeatHandler</code>，处理心跳请求——分配任务</li>
<li><code>MapFinishedHandler</code>，处理 Map 任务完成信息</li>
<li><code>ReduceFinishedHandler</code>，处理 Reduce 任务完成信息</li>
</ul>
<p>代码如下：</p>
<p>分配任务</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> HeartbeatHandler(request *Request, reply *Reply) <span class="type">error</span> &#123;</span><br><span class="line">	log.Println(<span class="string">&quot;Receive heartbeat from worker:&quot;</span>, request.WorkerId)</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">	workerId := request.WorkerId</span><br><span class="line">	<span class="keyword">if</span> workerId == <span class="number">0</span> &#123;</span><br><span class="line">		workerId = c.nextWorkerId</span><br><span class="line">		c.nextWorkerId++</span><br><span class="line">	&#125;</span><br><span class="line">	reply.WorkerId = workerId</span><br><span class="line">	workingTask, exist := c.working[workerId]</span><br><span class="line">	<span class="keyword">if</span> exist &#123; <span class="comment">// master的记录中该worker还在工作</span></span><br><span class="line">		<span class="comment">// 说明之前的任务可能失败了，需要将task重新入队</span></span><br><span class="line">		c.unassignTask(workingTask)</span><br><span class="line">		<span class="built_in">delete</span>(c.working, workerId)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> mapTask := &lt;-c.unassignedMaps:</span><br><span class="line">		<span class="comment">// 分配map</span></span><br><span class="line">		reply.Task = mapTask</span><br><span class="line">		reply.Command = MAPTASK</span><br><span class="line">		reply.NReduce = c.partition</span><br><span class="line">		c.assignedMaps[mapTask.TaskNo] = <span class="literal">false</span></span><br><span class="line">		c.working[workerId] = &amp;mapTask</span><br><span class="line">		<span class="keyword">go</span> c.checkStalled(workerId, &amp;mapTask)</span><br><span class="line">	<span class="keyword">default</span>: <span class="comment">// map全部分配了</span></span><br><span class="line">		<span class="keyword">if</span> allTaskFinished(c.assignedMaps) &#123; <span class="comment">// map全部执行完了</span></span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> reduceTask := &lt;-c.unassignedReduces:</span><br><span class="line">				<span class="comment">// 分配reduce</span></span><br><span class="line">				reply.Task = reduceTask</span><br><span class="line">				reply.Command = REDUCETASK</span><br><span class="line">				c.assignedReduces[reduceTask.TaskNo] = <span class="literal">false</span></span><br><span class="line">				c.working[workerId] = &amp;reduceTask</span><br><span class="line">				<span class="keyword">go</span> c.checkStalled(workerId, &amp;reduceTask)</span><br><span class="line">			<span class="keyword">default</span>: <span class="comment">// reduce分配完了 - 也有可能没完成初始化，所以需要isReducing判断</span></span><br><span class="line">				<span class="keyword">if</span> c.isReducing &amp;&amp; allTaskFinished(c.assignedReduces) &#123; <span class="comment">// reduce全部执行完了</span></span><br><span class="line">					reply.Command = QUIT <span class="comment">// 结束任务</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Map 任务完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">func (c *Coordinator) MapFinishedHandler(request *Request, reply *Reply) error &#123;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	defer c.mu.Unlock()</span><br><span class="line">	log.Println(<span class="string">&quot;Receive completion of map task from worker:&quot;</span>, request.WorkerId)</span><br><span class="line">	mapTask, ok := c.working[request.WorkerId]</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		c.assignedMaps[mapTask.TaskNo] = <span class="literal">true</span></span><br><span class="line">		<span class="title function_">delete</span><span class="params">(c.working, request.WorkerId)</span></span><br><span class="line">		<span class="comment">// 收集worker产生的中间文件名</span></span><br><span class="line">		<span class="keyword">for</span> rNo, file := range request.Intermediates &#123;</span><br><span class="line">			arr, ok := c.intermediates[rNo]</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				arr = []string&#123;file&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				arr = append(arr, file) <span class="comment">// 累加</span></span><br><span class="line">			&#125;</span><br><span class="line">			c.intermediates[rNo] = arr</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="title function_">len</span><span class="params">(c.assignedMaps)</span> == c.nMap &amp;&amp; allTaskFinished(c.assignedMaps) &#123; <span class="comment">// map全部分配完，并且全部完成</span></span><br><span class="line">			<span class="comment">// 初始化reduce任务</span></span><br><span class="line">			log.Println(<span class="string">&quot;start reduce&quot;</span>)</span><br><span class="line">			c.nReduce = len(c.intermediates) <span class="comment">// 这才是真正的reduce数量</span></span><br><span class="line">			<span class="keyword">for</span> rNo, files := range c.intermediates &#123;</span><br><span class="line">				<span class="comment">// log.Println(rNo, files)</span></span><br><span class="line">				c.unassignedReduces &lt;- Task&#123;REDUCETASK, rNo, files&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			c.isReducing = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;Worker&quot;</span>, request.WorkerId, <span class="string">&quot;&#x27;s result of map task was discarded.&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Reduce 任务完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func (c *Coordinator) ReduceFinishedHandler(request *Request, reply *Reply) error &#123;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	defer c.mu.Unlock()</span><br><span class="line">	log.Println(<span class="string">&quot;Receive completion of reduce task from worker:&quot;</span>, request.WorkerId)</span><br><span class="line">	reduceTask, ok := c.working[request.WorkerId]</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		c.assignedReduces[reduceTask.TaskNo] = <span class="literal">true</span></span><br><span class="line">		<span class="title function_">delete</span><span class="params">(c.working, request.WorkerId)</span></span><br><span class="line">		<span class="keyword">if</span> <span class="title function_">len</span><span class="params">(c.assignedReduces)</span> == c.nReduce &amp;&amp; allTaskFinished(c.assignedReduces) &#123; <span class="comment">// reduce全部分配完，并且全部完成</span></span><br><span class="line">			log.Println(<span class="string">&quot;=== Job done! ===&quot;</span>)</span><br><span class="line">			c.jobDone = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;Worker&quot;</span>, request.WorkerId, <span class="string">&quot;&#x27;s result of reduce task was discarded.&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在每次分配完任务后，都需要另起协程判断 Worker 是否阻塞（掉线）了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> checkStalled(workerId <span class="type">int</span>, task *Task) &#123;</span><br><span class="line">    time.Sleep(time.Second * time.Duration(WAIT_WORKER)) <span class="comment">// 等待一段时间</span></span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">    currTask, ok := c.working[workerId] <span class="comment">// 如果还能从working中获取到对应ID的任务</span></span><br><span class="line">    <span class="keyword">if</span> ok &amp;&amp; currTask == task &#123; <span class="comment">// 说明worker仍在执行之前的任务，需要踢出</span></span><br><span class="line">        c.unassignTask(task) <span class="comment">// 将task从已分配中删除，加入未分配队列</span></span><br><span class="line">        <span class="comment">// 删除工作记录</span></span><br><span class="line">        <span class="built_in">delete</span>(c.working, workerId)</span><br><span class="line">        log.Println(<span class="string">&quot;worker:&quot;</span>, workerId, <span class="string">&quot;was kicked out.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>测试全部通过：</p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://picgo-1259339555.cos.ap-nanjing.myqcloud.com/20231130200613.png"/></div></div>




</article>

<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2024/01/05/824%20Lab%202/">MIT6.824 分布式系统课程实验笔记 Lab 2</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2023/11/15/830%20Lab%206/">MIT6.830 SimpleDB 实现笔记 Lab 6</a></div></section></div>








      
<footer class="page-footer reveal fs12"><hr><div class="text"><p>本站由 <a href="/">@zyrate</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar">Stellar</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = stellar.config.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.19.0';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.19.0';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
    root : '/',
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.css","js":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.copycode = Object.assign({"enable":true,"js":"/js/plugins/copycode.js","default_text":"Copy","success_text":"Copied"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->



<!-- inject -->


  </div>
</body>
</html>
